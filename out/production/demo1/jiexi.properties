1=通知类型：分为前置通知、后置通知、异常通知、最终通知以及环绕通知;\
  一般前置通知是在目标方法之前执行，后置方法是在目标方法之后执行,\
  异常通知是在目标方法产生异常的时候执行，最终通知是无论程序运行结果如何都会执行.\
  前四种通知一般是我们使用xml配置文件方式的时候使用，只需要配置一次就能适用于设置\
  好的所有方法，如果使用注解配置的话，后置通知或者异常通知和最终通知的执行顺序会交换,\
  所以运行的结果会出错，所以一般在使用注释配置的时候都使用环绕通知，但是使用环绕通知的\
  时候当一个类中方法过多的时候，会需要多次配置，就会造成大量的代码重复，这不符合我们AOP\
  的思想，所以一般在工作中没有特别要求的话不会使用注解配置的方式.\
  前置通知：权限控制（权限不足抛出异常）、记录方法调用信息日志、计时、登陆验证等.\
  后置通知：提交事务，比如银行在存取款结束后的发送短信消息 ；异常通知：处理异常（一般不可预知),\
  记录日志最终通知：释放资源 （关闭文件、 关闭数据库连接、 网络连接、 释放内存对象!\
  环绕通知：目标方法执行前后，都进行增强（控制目标方法执行）应用 ：日志、缓存、权限、性能监控、事务管理!
2=jdk:要代理的对象必须实现接口,产生的代理对象和目标对象实现了相同的接口，代理对象和目标对象之间是兄弟关系。\
  java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。\
  Cglib:代理对象可以不需要去实现任何接口、产生的代理对象是目标对象的子类对象，代理对象继承了目标对象所对应的类。CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，比使用Java\
  反射效率要高。唯一需要注意的是，CGLib不能对声明为final的方法进行代理，因为CGLib原理是动态生成被代理类的子类。\
  在对JDK动态代理与CGlib动态代理的代码实验中看，1W次执行下，JDK7及8的动态代理性能比CGlib要好20%左右。
3=首先是用户发送请求，dispatcherServlet前端控制器接收到请求，然后再把请求分配给处理器映射器HandlerMapper,\
  那么HandlerMapper拿到了请求之后做了一番操作之后就返回了一个执行链(handler)给前端控制器，\
  前端控制器就又会将这个执行链发送给处理器适配器HandlerAdapter请求它来处理这个Handler,\
  这个处理器适配器就又找到了相对应的处理器来帮它完成这执行链的处理，处理器处理后会给处理器适配器返回一个ModelAndView\
  也就是一个字符串，也称为逻辑视图，拿到这个字符串之后又把它返回给了前端控制器，\
  最后前端控制器就会拿着这个逻辑视图去找视图解析器，ViewResolver会对逻辑视图进行渲染处理，最终呈现给用户。
4=HandlerMapping：处理器映射器:负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，\
  例如：配置文件方式，实现接口方式，注解方式等。HandlAdapter：处理器适配器:通过 HandlerAdapter 对处理器进行执行，\
  这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。View Resolver：\
  视图解析器: 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名 \
  即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。
5=共同点：它们都是表现层框架，都是基于MVC模型编写的。它们的底层都离不开原始 ServletAPI。\
  它们处理请求的机制都是一个核心控制器。区别：Spring MVC 的入口是 Servlet,而Struts2 是 \
  Filter，SpringMVC是基于方法设计的，而 Struts2 是基于类，Struts2 每次执行都会创建一个动作类。\
  所以SpringMVC会稍微比Struts2快些。 SpringMVC使用更加简洁,同时还支持JSR303,\
  处理ajax的请求更方便 (JSR303 是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，\
  我们可以直接将这些注解加在我们JavaBean的属性上面，就可以在需要校验的时候进行校验了。) \
  Struts2的OGNL表达式使页面的开发效率相比SpringMVC更高些，但执行效率并没有比JSTL提升，\
  尤其是struts2 的表单标签，远没有html执行效率高。